/*
 * Copyright  2004 Mass Dosage
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
package za.co.massdosage.ant;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

import junit.framework.TestCase;
import junit.framework.TestSuite;

import org.apache.tools.ant.BuildException;

/**
 * Tests the functioning of the <code>Crypter</code>.
 *
 * @author mass
 */
public class CrypterTest extends TestCase {
    
    //TODO add output when generating keys etc?
    
    private final static String BLOWFISH_KEY_ALGORITHM = "Blowfish";
    private final static String BLOWFISH_TRANSFORMATION = "Blowfish/ECB/PKCS5Padding";
    private final static String	DES_KEY_ALGORITHM = "DES";
    private final static String DES_TRANSFORMATION = "DES/ECB/PKCS5Padding";
    
    private static final String DATA_PATH = "test/data/za/co/massdosage/ant/";
    private static final String TEMP_PATH = "test/temp/";
    private File tempFolder = new File(TEMP_PATH);
    
    private File keyFile ;
    private File encryptedFile ;
    private File textInputFile = new File(DATA_PATH, "test.html");
    private File binaryInputFile = new File(DATA_PATH,  "test.bin");
    private File decryptedFile ;
    
    /**
     * Asserts that required data files exist and no generated files left over from a previous test.
     */
    public void setUp() {
        String random = "" + Math.random(); //need to generate random file names 'cos bloody windows often doesn't delete files
        this.keyFile = new File(TEMP_PATH, random + "key.ser");
        this.encryptedFile = new File(TEMP_PATH, random + "encrypted");
        this.decryptedFile = new File(TEMP_PATH, random +  "decrypted");
        this.cleanup();
        assertTrue("Missing text input file " + textInputFile.getAbsolutePath(), textInputFile.exists());
        assertTrue("Missing binary input file " + binaryInputFile.exists(), binaryInputFile.exists());
        assertTrue("Should not have a pre-existing key file " + keyFile.getAbsolutePath(), !keyFile.exists());
        assertTrue("Should not have a pre-existing decrypted file " + decryptedFile.getAbsolutePath(), !decryptedFile.exists());
        assertTrue("Should not have a pre-existing encrypted file " + encryptedFile.getAbsolutePath(), !encryptedFile.exists());
    }
    
    /**
     * Deletes all files which might be generated by test methods.
     */
    protected void tearDown() {
        this.cleanup();
    }
    
    /**
     * Cleans up files that should be cleaned up inbetween tests.
     */
    private void cleanup() {
        if (keyFile.exists()) {
            keyFile.delete();
            keyFile.deleteOnExit();
        }
        if (encryptedFile.exists()) {
            encryptedFile.delete();
            encryptedFile.deleteOnExit();
        }
        if (decryptedFile.exists()) {
            decryptedFile.delete();
            decryptedFile.deleteOnExit();
        }
        if (tempFolder.exists()) {
            tempFolder.delete();
            tempFolder.deleteOnExit();
        }
    }
    
    /**
     * Checks whether two <code>File</code>'s are equal at a binary level.
     * 
     * @param file1 <code>File</code> to compare.
     * @param file2 Other <code>File</code> to compare.
     * @return <code>true</code> if the <code>File</code>'s are equal; <code>false</code> otherwise.
     */
    private boolean fileContentsEqual(File file1, File file2) {
        try {
            BufferedInputStream expectedStream = new BufferedInputStream(new FileInputStream(file1));
            BufferedInputStream actualStream = new BufferedInputStream(new FileInputStream(file2));
            byte[] expectedBytes = new byte[expectedStream.available()];
            byte[] actualBytes = new byte[actualStream.available()];
            if (expectedBytes.length != actualBytes.length) {
                return false;
            }
            expectedStream.read(expectedBytes);
            actualStream.read(actualBytes);
            expectedStream.close();
            actualStream.close();
            return expectedBytes.equals(actualBytes);
        } catch (IOException e) {
            e.printStackTrace();
            fail(e.getMessage());
        }
        return false;
    }
    
    /**
     * Tests running the <code>Crypter</code> with nothing specified. 
     */
    public void testNoArguments() {
        //should do nothing
        Crypter testCryper = new Crypter();
        testCryper.execute();
        assertTrue("Decrypted file should not be generated", !decryptedFile.exists());
        assertTrue("Encrypted file should not be generated", !encryptedFile.exists());
        assertTrue("Key file should not be generated", !keyFile.exists());
    }
    
    /**
     * Tests trying to generate a key without specifying a key file.
     */
    public void testGenerateKeyNoKeyFile() {
        Crypter testCrypter = new Crypter();
        testCrypter.setGenerateKey(true);
        try {
            testCrypter.execute();
            fail("Should not be able to generate a key without specifying a key file");
        } catch (BuildException e) {
            //this should happen
        }
        assertTrue("Decrypted file should not be generated", !decryptedFile.exists());
        assertTrue("Encrypted file should not be generated", !encryptedFile.exists());
        assertTrue("Key file should not be generated", !keyFile.exists());
    }
    
    /**
     * Tests generating a key, encrypting and decrypting a text file with it. 
     */
    public void testAllDefaultsText() {
        Crypter testCrypter = new Crypter();//by default should do encryption
        testCrypter.setGenerateKey(true);
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setInputFile(this.textInputFile);
        testCrypter.setOutputFile(this.encryptedFile);
        testCrypter.execute();
        assertTrue("Key file should be generated", keyFile.exists());
        assertTrue("Encrypted file should be generated", encryptedFile.exists());
        assertTrue("Decrypted file shouldn't be generated yet", !decryptedFile.exists());
        assertTrue("Encrypted file should be different from orginal", !fileContentsEqual(textInputFile, encryptedFile));
        
        testCrypter = new Crypter(); //by default should not generate a new key
        testCrypter.setEncrypt(false);
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setInputFile(this.encryptedFile);
        testCrypter.setOutputFile(this.decryptedFile);
        testCrypter.execute();
        assertTrue("Decrypted file should be generated", decryptedFile.exists());
        assertTrue("Decrypted file should be same as orginal", !fileContentsEqual(textInputFile, decryptedFile));
    }
    
    /**
     * Tests generating a key, encrypting and decrypting a binary file with it. 
     */
    public void testAllDefaultsBinary() {
        Crypter testCrypter = new Crypter(); //by default should do encryption
        testCrypter.setGenerateKey(true);
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setInputFile(this.binaryInputFile);
        testCrypter.setOutputFile(this.encryptedFile);
        testCrypter.execute();
        assertTrue("Key file should be generated", keyFile.exists());
        assertTrue("Encrypted file should be generated", encryptedFile.exists());
        assertTrue("Encrypted file should be different from orginal", !fileContentsEqual(binaryInputFile, 
                encryptedFile));
        assertTrue("Decrypted file shouldn't be generated yet", !decryptedFile.exists());
        
        testCrypter = new Crypter(); //by default should not generate a new key
        testCrypter.setEncrypt(false);
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setInputFile(this.encryptedFile);
        testCrypter.setOutputFile(this.decryptedFile);
        testCrypter.execute();
        assertTrue("Decrypted file should be generated", decryptedFile.exists());
        assertTrue("Decrypted file should be same as orginal", !fileContentsEqual(binaryInputFile, decryptedFile)); 
    }
    
    /**
     * Tests encrypting a file with one key and then decrypting it with another.
     */
    public void testDifferentKey() {
        Crypter testCrypter = new Crypter(); 
        testCrypter.setGenerateKey(true);
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setEncrypt(true);
        testCrypter.setInputFile(this.binaryInputFile);
        testCrypter.setOutputFile(this.encryptedFile);
        testCrypter.execute();
        assertTrue("Key file should be generated", keyFile.exists());
        assertTrue("Encrypted file should be generated", encryptedFile.exists());
        assertTrue("Encrypted file should be different from orginal", !fileContentsEqual(binaryInputFile, 
                encryptedFile));
        assertTrue("Decrypted file shouldn't be generated yet", !decryptedFile.exists());
        
        testCrypter = new Crypter();
        testCrypter.setEncrypt(false);
        testCrypter.setGenerateKey(true); //generate a new key, should cause decryption to fail
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setInputFile(this.encryptedFile);
        testCrypter.setOutputFile(this.decryptedFile);
        testCrypter.execute();
        assertTrue("Decrypted file should be generated", decryptedFile.exists());
        assertTrue("Decrypted file should be different from orginal due to different key", 
                !fileContentsEqual(binaryInputFile, decryptedFile));
    }
    
    /**
     * Tests encrypting a file using default key (which is Blowfish) and a specified Blowfish transformation. 
     */
    public void testDefaultAlgorithmSpecificTransformation() {
        Crypter testCrypter = new Crypter(); //by default should do encryption
        testCrypter.setGenerateKey(true);
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setCipherTransformation(BLOWFISH_TRANSFORMATION);
        testCrypter.setInputFile(this.binaryInputFile);
        testCrypter.setOutputFile(this.encryptedFile);
        testCrypter.execute();
        assertTrue("Key file should be generated", keyFile.exists());
        assertTrue("Encrypted file should be generated", encryptedFile.exists());
        assertTrue("Encrypted file should be different from orginal", !fileContentsEqual(binaryInputFile, 
                encryptedFile));
        assertTrue("Decrypted file shouldn't be generated yet", !decryptedFile.exists());
        
        testCrypter = new Crypter(); //by default should not generate a new key
        testCrypter.setEncrypt(false);
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setCipherTransformation(BLOWFISH_TRANSFORMATION);
        testCrypter.setInputFile(this.encryptedFile);
        testCrypter.setOutputFile(this.decryptedFile);
        testCrypter.execute();
        assertTrue("Decrypted file should be generated", decryptedFile.exists());
        assertTrue("Decrypted file should be same as orginal", !fileContentsEqual(binaryInputFile, decryptedFile)); 
    }
    
    /**
     * Tests encrypting and decrypting a file using an alternative algorithm (in this case DES).
     */
    public void testDESTransformationAndKey() {
        Crypter testCrypter = new Crypter(); //by default should do encryption
        testCrypter.setGenerateKey(true);
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setKeyAlgorithm(DES_KEY_ALGORITHM);
        testCrypter.setCipherTransformation(DES_TRANSFORMATION);
        testCrypter.setInputFile(this.binaryInputFile);
        testCrypter.setOutputFile(this.encryptedFile);
        testCrypter.execute();
        assertTrue("Key file should be generated", keyFile.exists());
        assertTrue("Encrypted file should be generated", encryptedFile.exists());
        assertTrue("Encrypted file should be different from orginal", !fileContentsEqual(binaryInputFile, 
                encryptedFile));
        assertTrue("Decrypted file shouldn't be generated yet", !decryptedFile.exists());
        
        testCrypter = new Crypter(); //by default should not generate a new key
        testCrypter.setEncrypt(false);
        testCrypter.setKeyFile(this.keyFile);
        //testCrypter.setKeyAlgorithm(DES_KEY_ALGORITHM);
        testCrypter.setCipherTransformation(DES_TRANSFORMATION);
        testCrypter.setInputFile(this.encryptedFile);
        testCrypter.setOutputFile(this.decryptedFile);
        testCrypter.execute();
        assertTrue("Decrypted file should be generated", decryptedFile.exists());
        assertTrue("Decrypted file should be same as orginal", !fileContentsEqual(binaryInputFile, decryptedFile)); 
    }
    
    /**
     * Tests encrypting a file using a DES key but decrypting it using a Blowfish key. 
     */
    public void testKeyMismatch() {
        Crypter testCrypter = new Crypter(); //by default should do encryption
        testCrypter.setGenerateKey(true);
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setKeyAlgorithm(DES_KEY_ALGORITHM);
        testCrypter.setCipherTransformation(DES_TRANSFORMATION);
        testCrypter.setInputFile(this.binaryInputFile);
        testCrypter.setOutputFile(this.encryptedFile);
        testCrypter.execute();
        
        File keyFile2 = new File(TEMP_PATH, Math.random()+ "key.ser");
        testCrypter = new Crypter(); 
        testCrypter.setEncrypt(false);
        testCrypter.setGenerateKey(true);
        testCrypter.setKeyAlgorithm(BLOWFISH_KEY_ALGORITHM);
        testCrypter.setKeyFile(keyFile2);
        testCrypter.setCipherTransformation(DES_TRANSFORMATION);
        testCrypter.setInputFile(this.encryptedFile);
        testCrypter.setOutputFile(this.decryptedFile);
        try {
            testCrypter.execute();
            fail("Should not be able to decrypt a DES file with a Blowfish key");
        } catch (BuildException e) {
            //this should happen
        } finally {
            keyFile2.delete();
        }
    }
    
    /**
     * Tests encrypting a file with a DES key but a Blowfish transform. 
     */
    public void testTransformationMismatchOnEncrypt() {
        Crypter testCrypter = new Crypter(); //by default should do encryption
        testCrypter.setGenerateKey(true);
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setKeyAlgorithm(DES_KEY_ALGORITHM);
        testCrypter.setCipherTransformation(BLOWFISH_TRANSFORMATION);
        testCrypter.setInputFile(this.binaryInputFile);
        testCrypter.setOutputFile(this.encryptedFile);
        try {
            testCrypter.execute();
            fail("Should not be able to encrypt with a DES key and Blowfish transformation");
        } catch (BuildException e) {
            //this should happen
        }
    }
    
    /**
     * Tests encrypting a file correctly using DES, then trying to decrypt it with DES key but Blowfish transform.
     */
    public void testTransformationMismatchOnDecrypt() {
        Crypter testCrypter = new Crypter(); //by default should do encryption
        testCrypter.setGenerateKey(true);
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setKeyAlgorithm(DES_KEY_ALGORITHM);
        testCrypter.setCipherTransformation(DES_TRANSFORMATION);
        testCrypter.setInputFile(this.binaryInputFile);
        testCrypter.setOutputFile(this.encryptedFile);
        testCrypter.execute();
        
        testCrypter = new Crypter(); //by default should not generate a new key
        testCrypter.setEncrypt(false);
        testCrypter.setKeyFile(this.keyFile);
        testCrypter.setCipherTransformation(BLOWFISH_TRANSFORMATION);
        testCrypter.setInputFile(this.encryptedFile);
        testCrypter.setOutputFile(this.decryptedFile);
        try {
            testCrypter.execute();
            fail("Should not be able to decrypt a DES file with a Blowfish transformation");
        } catch (BuildException e) {
            //this should happen
        }
    }
    
    /**
     * Main method for running this test from the command line.
     * 
     * @param args Command line arguments (ignored).
     */
    public static void main(String[] args) {
        junit.textui.TestRunner.run(new TestSuite(CrypterTest.class));
    }
    
}
